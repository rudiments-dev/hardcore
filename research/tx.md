# `Tx`
cпециальная локация, в которую помещаются
* команды, запросы - для управления потоком исполнения и ведения бизнес-стэка
* события - для фиксации изменений системы, захвата ресурсов, выполнения промежуточных вычислений (в т.ч. проверок)
* отчеты - как кэш и с целью перепроверки результатов в случае импакта конкурентных транзакций

## Life cycle
`In -> ([validate] -> new Tx) -> [prepare] -> [execute] -> [verify] -> (Tx.commit -> Out)`

Транзакция в типичном случае создается после валидации запроса/команды, но перед выполнением "тяжелой" работы, такой как
* обращением к диску
* обращением по сети (включая БД и другие сервисы)
* захватом блокировок
* захватом ограниченных ресурсов

Коммит формируется после всех изменений, вызванных исполнением запроса/команды.

У транзакции в рудиментах нет прямой привязки к поведению - потокам, дескрипторам, блокировкам, семафорам и т.п., они могут присутствовать в виде событий в `Tx`, но не управляются самой транзакцией.

Транзакции могут исполняться параллельно, в т.ч. это означает что можно выделять "системную транзакцию" при запуске приложения, где фиксировать системные события (вместо логирования).


# `Commit`
зафиксированный результат транзакции
* события (что изменяется в системе если применить коммит)
* запросы и репорты, необходимые для проверки и поддержания целостности
* не входят (но это не точно) - системные события, такие как захваты и освобождения локов, ресурсов из пулов. Вероятно, не все обращения к агентам и адаптерам (например - запись на диск).

## Check-sums
У транзакции можно сформировать контрольные суммы:
1. data - чексумма всех данных, входящих в коммит
2. chain - чексумма данных и родительского коммита
3. signature - чексумма цепи, реквизитов пользователя и соли

Если в качестве суммы родительсткого коммита брать подпись, то последовательность коммитов с их подписями становится защищенной от подделок аналогично block chain.


## Commit ops
Над коммитами можно выполнять несколько операций:
* дополнение `C#1 +> C#2 = C#3` - в `C#3` будут изменения `C#1` и после них все изменения `C#2`. В случае противоречия - ошибка.
* сравнение `C#1 Δ C#2 = only#1 | same | varied | only#2` - группировка по идентификаторам между коммитами
    * вещи только в `C#1`
    * одинаковые вещи в обоих коммитах
    * различные вещи в двух коммитах
    * вещи только в `C#2`

Кейс `C#1 Δ C#2 = only#1 | ∅ | ∅ | only#2` - это не пересекающиеся коммиты, порядок их применения к системе неважен.

Кейсы с непустыми `same` могут обрабатываться в зависимости от потребностей системы, это может быть как признак взаимной консистентности, так и признак конфликта изменений.

Непустой `varied` может быть консистентным или противоречивым. Если он консистентный, то транзакции могут быть применены (но обязательно - в указанном порядке) `C#1 +> C#2`.

## Version
Коммиты подчиняются принципу `Event-carried state transfer`, это значит что последовальность коммитов определяет состояние.

Версия - это итоговое состояние и приведшая к нему последовательность коммитов.

Транзакции можно рассматривать как разные версии, отведенные от общей "мастер-версии".

# Use cases
## Call
Тривиальная, одна-на-вызов транзакция, которая точно завершается быстро
- Создается после предварительной валидации запроса/команды.
- при завершении вызова транзакция завершается. Если вызов успешный - коммитом, если ошибочный - откатом.

## Session
Сессия предполагает цепочку растянутых во времени и по вызовам транзакций
- создается при первом вызове или явно
- при завершении вызова формируется коммит с изменениями данных, он сохраняется в отдельное хранилище
- при очередном вызове восстанавливается последний коммит, его данные передаются в транзакцию вызова. В этот момент происходит обновление данных (rebase)
- окончание сессии - по определенному действию

## Batch
- для работы с большим количеством данных
- предполагается, что один батч выполняется за одну или несколько системных транзакций
- границы системных транзакций продиктованы балансом скорости обработки и восстановления данных в случае сбоя